# 2. URL과 리소스

**URL**(Uniform Resource Locator)은 인터넷의 리소스를 가리키는 표준이름입니다. URL은 전자정보 일부를 가리키고 그것이 어디에 있고 어떻게 접근할 수 있는지 알려줍니다.

## 2.1 인터넷의 리소스 탐색하기

URL은 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리키며, URL을 이용해 사람과 애플리케이션이 인터넷상의 수십억 개의 리소스를 찾고 사용하며 공유할 수 있습니다. 그리고 URL을 통해 사람이 HTTP 및 다른 프로토콜을 통해 접근할 수 있습니다.사용자는 브라우저에 URL을 입력하고 브라우저는 화면 뒤에서 사용자가 원하는 리소스를 얻기 위해서 적절한 프로토콜을 사용하여 메시지를 전송합니다.

URL은 **통합 자원 식별자**(Uniform Resource Identifier) 혹은 URI라고 불리는 더 일반화된 부류의 부분집합입니다. URI는 두 가지 주요 부분집합인, URL과 URN으로 구성된 종합적인 개념입니다. URN은 현재 그 리소스가 어디에 존재하든 상관없이 그 이름만으로 리소스를 식별하는데 비해 URL은 리소스가 어디 있는지 설명해서 리소스를 식별합니다. HTTP 명세에서는 URI를 더 일반화된 개념의 리소스 식별자로 사용합니다. 하지만 실제로 HTTP 애플리케이션은 URL을 URI의 한 부분으로 취급합니다.

![URL이 브라우저, 컴퓨터, 서버, 서버 파일 시스템의 어디에 위치하고 어떻게 연결되는지 보여줍니다.](../_images/http0201.png)

- URL첫 부분인 `http`는 URL의 스킴입니다. 스킴은 웹 클라이언트가 리소스에 어떻게 젒근하는지 알려줍니다. URL은 HTTP 프로토콜이 아닌 다른 가용한 프로토콜을 사용할 수 있습니다.
- URL의 두 번째 부분인 `www.joes-hardware.com`은 서버 위치입니다. 이는 웹 클라이언트가 리소스가 어디에 호스팅 되어 있는지 알려줍니다.
- URL의 세 번째 부분인 `/seasonal/index-fall.html`은 리소스의 경로입니다. 경로는 서버에 존재하는 로컬 리소스들 중에서 요청받은 리소스가 무엇인지 알려줍니다.

URL을 사용하면 리소스를 일관된 방식으로 지칭할 수 있습니다. 대부분의 URL은 동일하게 `스킴://서버위치/경로` 구조로 이루어져 있습니다. 따라서 인터넷상의 모든 시로스를 가리키고 가져오기 위해, 그리고 모든 사람이 같은 방식으로 이름을 써서 리소스를 찾을 수 있도록, 단일 방식의 작명 규칙을 가진 것입니다. 하지만 처음부터 일관된 명명 방식이 있었던 것은 아닙니다. 웹과 URL이 있기 전에 사람들은 네트워크상에 산재해 있는 데이터에 접근하기 위해, 오합지졸에 가까울 정도로 애플리케이션마다 달리 가지고 있는 분류 방식을 사용했습니다. 오늘날 브라우저들은 이러한 기능들을 한 개의 편리한 패키지에 담아놓았습니다. URL을 사용하면 이런 애플리케이션들에서 하나의 인터페이스를 통해 일관된 방식으로 많은 리소스에 접근할 수 있습니다.

## 2.2 URL 문법

URL로 인터넷상의 모든 리소스를 찾을 수 있지만, 그 리소스들은 다른 스킴을 통해 접근할 수 있으며, URL 문법은 스킴에 따라서 달라집니다. 허자먼 대부분의 URL은 일반 URL 문법을 따르며, 서로 다른 URL 스킴도 형태와 문법 면에서 매우 유사합니다. 대부분의 URL 스킴의 문법은 일반적으로 9개 부분으로 나뉩니다. 모든 컴포넌트를 가지는 URL은 거의 없습니다.

```
<스킴>://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```

### 2.2.1 스킴: 사용할 프로토콜

스킴은 리소스를 가져오려면 어떤 프로토콜을 사용하여 서버에 접근해야 하는지 가리키는 중요한 정보입니다. 이는 URL을 해석하는 애플리케이션이 어떤 프로토콜을 사용하여 리소스를 요청해야 하는지 알려줍니다. 스킴 컴포넌트는 알파벳으로 시작해야 하고 URL의 나머지 부분들과 첫 번째 `:` 문자로 구분합니다.

### 2.2.2 호스트와 포트

애플리케이션이 인터넷에 있는 리소스를 찾으려면, 리소스를 호스팅하고 있는 장비와 그 장비 내에서 리소스에 접근할 수 있는 서버가 어디에 있는지 알아야 합니다. URL의 호스트와 포트 컴포넌트는 그 두 가지 정보를 제공해줍니다. 호스트 컴포넌트는 접근하려고 하는 리소스를 가지고 있는 인터넷상의 호스트 장비를 가리키며, 호스트 명이나 IP 주소로 제공합니다. 포트 컴포넌트는 서버가 열어놓은 네트워크 포트를 가리킵니다. 내부적으로 TCP 프로토콜을 사용하는 HTTP는 기본 포트로 `80`을 사용합니다.

### 2.2.3 사용자 이름과 비밀번호

더 흥미로운 컴포넌트는 사용자 이름과 비밀번호 컴포넌트입니다. 몇몇 스킴은 리소스에 접근을 하기 위해 사용자 이름과 비밀번호를 요구합니다. `@` 문자는 URL로부터 사용자 이름과 비밀번호 컴포넌트를 분리합니다. 사용자 이름과 비밀번호는 `:` 문자로 분리합니다.

```
ftp://ftp.prep.ai.mit.edu/pub/gnu
ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
ftp://anonymous:my_pass@ftp.prep.ai.mit.edu/pub/gnu
http://joe:joespasswd@www.joes-hardware.com/sales_info.txt
```

애플리케이션이 FTP와 같이 사용자 이름과 비밀번호를 요구하는 URL 스킴을 사용한다면, 그 값들이 삽입되어 있지 않을 경우 기본 사용자 이름과 비밀번호 값을 넣어놓을 것입니다. 예를 들어, 사용자 이름과 비밀번호를 기술하지 않고 FTP URL에 접근하면, 기본 사용자 이름 값으로 `anonymous`가, 비밀번호는 브라우저마다 가지고 있는 기본값을 사용합니다.

### 2.2.4 경로

URL의 경로 컴포넌트는 리소스가 서버의 어디에 있는지 알려줍니다. 경로 컴포넌트의 문법은 서버와 스킴에 따라 다릅니다. HTTP URL에서 경로 컴포넌트는 유닉스 파일 시스템의 파일 경로와 유사하며, `/` 문자를 기준으로 경로조각으로 나뉩니다. 각 경로조각은 자체만의 파라미터 컴포넌트를 가질 수 있습니다.

```
http://www.joes-hardware.com:80/seasonal/index-fall.html
```

### 2.2.5 파라미터

URL을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요합니다. 프로토콜 파라미터가 없으면, 다른 한편에 있는 서버는 그 요청을 잘못 처리하거나 처리하지 않을 것입니다. URL의 파라미터 컴포넌트는, 애플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는데 사용합니다. 이 컴포넌트는 이름/값 쌍의 리스트로 URL 나머지 부분들로부터 `;` 문자로 구분하여 URL에 기술합니다. 이를 통해 애플리케이션이 리소스에 접근하는데 필요한 어떤 추가 정보든 전달할 수 있습니다.

```
ftp://prep.ai.mit.edu/pub/gnu;type=d
```

앞서 언급했듯이, HTTP URL에서의 경로 컴포넌트는 경로 조각으로 나눌 수 있습니다. 각 조각은 자체 파라미터를 가질 수 있습니다.

```
http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true
```

### 2.2.6 질의 문자열

스킴에서 애플리케이션에 파라미터를 전달하는데 쓰입니다. 데티어베이스 같은 서비스들은 요청받을 리소스 형식의 범위를 좁히기 위해서 질문이나 질의를 받을 수 있습니다. URL의 질의 컴포넌트는 게이트웨이를 가리키는 URL의 경로 컴포넌트와 함께 전달하고 있습니다. 보통 게이트웨이는, 다른 애플리케이션에 접근하려고 할 떄 거치는 통로라고 할 수 있습니다. 사용하면 안 되는 특정 문자들을 제외하고 질의 컴포넌트 포맷에 제약사항을 없습니다. 편의상 많은 게이트웨이가 `&`로 나뉜 `이름=값` 쌍 형식의 질의 문자열을 원합니다.

```
http://www.joes-hardware.com/inventory-check.cgi?item=127316&color=blue
```

### 2.2.7 프래그먼트

HTML 같은 리소스 형식들은 본래의 수준보다 더 작게 나뉠 수 있습니다. 예를 들어 절(Paragraph)이 포함된 용량이 큰 한개의 텍스트 문서의 경우, 그 리소스에 대한 URL은 텍스트 문서 전체를 가리키겠지만, 이상적으로는 리소스 안에 있는 특정 절을 가리킬 수 있어야 합니다. 리소스의 특적 부분을 가리킬 수 있도록, URL은 리소스 내의 조각을 가리킬 수 있는 프래그먼트 컴포넌트를 제공합니다. 프래그먼트는 URL의 오른쪽에 `#` 문자에 이어서 옵니다. 일반적으로 HTTP 서버는 객체 일부가 아닌 전체만 다루기 때문에, 클라이언트는 서버에 프래그먼트를 전달하지 않습니다. 브라우저가 서버로부터 전체 리소스를 내려받은 후, 프래그먼트를 사용하여 당신이 보고자 하는 리소스의 일부를 보여줍니다.

![서버는 객체를 전체 단위로만 전송하기 떄문에 URL 프래그먼트는 클라이언트에서만 사용됩니다.](../_images/http0203.png)

## 2.3 단축 URL

웹 클라이언트는 몇몇 단축 URL을 인식하고 사용합니다. 상대 URL은 리소스 안에 있는 리소스를 간결하게 기술하는데 사용할 수 있습니다. 많은 브라우저가 사용자가 기억하고 있는 URL 일부를 입력하면 나머지 부분을 자동으로 입력해주는 URL **자동 확장**을 지원합니다.

### 2.3.1 상대 URL

URL은 상대 URL과 절대 URL 두 가지로 나뉩니다. 절대 URL은 리소스에 접근하는데 필요한 모든 정보를 가지고 있습니다. 그와 달리 상대 URL은 URL을 짧게 표기하는 방식아며, URL에 스킴과 호스트 그리고 다른 컴포넌트들을 모두 입력하지 않아도 됩니다. 상대 URL로 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는, **기저**(Base)라고 하는 다른 URL을 사용해야 합니다. URL을 처리하는 브라우저 같은 애플리케이션은 상대 URI과 절대 URI 간에 상호 변환을 할 수 있어야 합니다.

```
기저 URL: http://www.joes-hardware.com/tools.html
상대 URL: ./hammers.html
새로운 절대 URL: http://www.joes-hardware.com/hammers.html
```

#### 기저 URL

변환 과정의 첫 단계는 기저 URL을 찾는 것입니다. 기저 URL은 상대 URL의 기준이 됩니다. 이것을 가져오는 몇 가지 방법이 있습니다.

1. **리소스에서 명시적으로 제공**: 어떤 리소스들은 기저 URL을 명확하게 기술하기도 합니다. 예를 들어 HTML 문서에서는 그 안에 있는 모든 상대 URL을 변경하기 위해서 기저 URL을 가리키는 `<BASE>` HTML 태그를 기술할 수 있습니다.
2. **리소스를 포함하고 있는 기저 URL**: 만약 상대 URL이 기저 URL이 명시되지 않은 리소스에 포함된 경우, 해당 리소스의 URL을 기저 URL로 쓸 수 있습니다.
3. **기저 URL이 없는 경우**: 기저 URL이 없는 경우도 있습니다. 보통 이런 경우는 절대 URL만으로 이루어져 있드난 뜻입니다. 하지만 불완전하거나 깨진 URL일 수도 있습니다.

#### 상대 참조 해석하기

상대 URL을 절대 URL로 변환하기 위한 다음 단계는 상대 URL과 기저 URL을 각각 컴포넌트 조각으로 나누는 것입니다. 사실상 이것은 URL을 파싱하는 것에 불과하지만, 컴포넌트 단위로 분리한다는 점에서 이작업을 **URL 분해하기**라고 부르기도 합니다. 기저 URL과 상대 URL을 컴포넌트로 분해하고 나면, 변환을 끝내기 위해 다음과 같은 알고리즘을 사용합니다. 이 알고리즘은 상대 URL을 리소스를 참조하는데 사용할 수 있는 절대 경로 형태로 변환합니다. 이 알고리즘은 RFC 1808에 최초로 기술되었고, 그 이후 RFC 2396에 포함되었습니다.

![상대 URL을 절대 URL로 변환하기](../_images/http0205.png)

### 2.3.2 URL 확장

어떤 브라우저들은 URL을 입력한 다음이나 입력하고 있는 동안에 자동으로 URL을 확장합니다. 이는 사용자가 URL을 빠르게 입력하게 도와줍니다. 자동으로 URL이 확장되기 때문에 URL 전체를 입력하지 않아도 됩니다. 이런 **확장** 기능은 두 가지로 나뉩니다.

#### 호스트 명 확장

호스트 명 확장 기능을 지원하는 브라우저는 단순한 휴리스틱만을 사용해서 입력한 호스트 명을 전체 호스트 명으로 확장할 수 있습니다. 예를 들어 주소 입력란에 `yahoo`를 입력하면, 브라우저는 호스트 명에 자동으로 `www`와 `.com`을 붙여서 `www.yahoo.com`을 만듭니다. 어떤 브라우저는 `yahoo`란 단어를 포함한 사이트를 찾지 못하면, 확장을 포기하기 전에 몇 가지의 URL을 추가로 제시합니다.

브라우저는 이런 간단한 기능을 제공하여 사용자의 시간을 절약하고 혼란을 막아줍니다. 하지만 호스트 명에 대한 확장 기능은 프락시와 같은 다른 HTTP 애플리케이션에 문제를 발생시킬 수도 있습니다.

#### 히스토리 확장

사용자가 URL을 입력하는 시간을 줄이고자, 브라우저가 사용하는 또 다른 기술은 과게에 사용자가 방문했던 URL의 기록을 저장해 놓는 것입니다. URL을 입력하면, 그 입력된 URL의 앞 글자들을 포한하는 완결된 형태의 URL들을 선택하게 해줍니다. 그러면 사용자는 전체 URL을 입력하는 대신 선택만 하면 됩니다.

프락시를 사용할 경우 URL 자동확장 기능은 다르게 동작할 수 있다는 것을 유념합니다. 이에 대해서는 **6장 URI 클라이언트 자동확장과 호스트 명 분석**에서 상세히 다룰 것입니다.

## 2.4 안전하지 않은 문자

URL은 잘 호환되도록 설계되었습니다. 그리고 URL은 인터넷에 있는 모든 리소스가 여러 프로토콜을 통해서 전달될 수 있도록, 각 리소스에 유일한 이름을 지을 수 있게 설계되었습니다. 모든 프로토콜이 데이터를 전송하기 위해서 서로 다른 장치를 가지고 있기 때문에, 어떤 인터넷 프로토콜을 통해서든 안전하게 전송될 수 있도록 URL을 설계하는 것은 중요했습니다. 안전한 전송이란, 정보가 유실될 위험 없이 URL을 전송할 수 있다는 것을 의미합니다.

문자가 제거되는 일을 피하고자 URL은 상대적으로 작고 일반적으로 안전한 알파벳 문자만 포함하도록 허락합니다. URL 설계자들은, 모든 인터넷 프로토콜로 URL이 전송될 수 있기를 바랐고, 이와 함께 가독성도 있기를 바랐습니다. 따라서 출력이 되지 않거나 보이지 않는 문자를 프로그램에서 사용할 수 있다고 해서, 그리고 그 문자들이 변환될 수 있다고 하더라도, URL에서 그런 문자를 사용하는 것은 금지되었습니다.

여기서 더하여 URL은 더 완벽해져야 했습니다. URL 설계자는 사람들이 URL에 이진 데이터나 일반적으로 안전한 알파벳 외의 문자도 포함하려고 할 때가 있다는 것을 알게 되었습니다. 그래서 이스케이프라는 기능을 추가하여, 안전하지 않은 문자를 안전한 문자로 인코딩할 수 있게 하였습니다.

### 2.4.1 URL 문자 집합

컴퓨터 시스템의 기본 문자 집합은 보통 영어 중심으로 설정되어 있습니다. 역사적으로 많은 컴퓨터 애플리케이션이 US-ASCII 문자 집합을 사용해 왔습니다. US-ASCII는 문자를 서식화하고 하드웨어상에서 신호를 주고받기 위해, 7비트를 사용하여 영문 자판에 있는 키 대부분과 몇몇 출력되지 않는 제어 문자를 표현합니다. US-ASCII는 만들어진지 오래된 문자 집합이기 때문에, 적은 수의 문자만을 포함하고 있습니다. 미국 시민들 사이에서는 편리하게 쓰이고 있기는 하지만, 전 세계 십수억의 사람들이 사용하는 유럽 언어나 수백 가지의 비 라틴계 언어들에 존재하는 변형된 문자들까지 US-ASCII가 지원하지는 않습니다.

그 뿐만 아니라 URL이 특정 이진 데이터를 포함해야 하는 경우도 있습니다. 이런 것들을 지원하기 위해서, URL 설계자들은 URL에 이스케이프 문자열을 쓸 수 있게 설계했습니다. 이스케이프 문자열은 US-ASCII에서 사용이 금지된 문자들로, 특정 문자나 데이터를 인코딩할 수 있게 함으로써 이동성과 완성도를 높였습니다.

### 2.4.2 인코딩 체계

안전한 문자 집합을 이용하는 경우 그 표현의 한곙를 넘기 위해, URL에 있는 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안되었습니다. 인코딩은 안전하지 않은 문자를 퍼센티지 기호(`%`)로 시작해, ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어진 **이스케이프** 문자로 바꿉니다.

| 문자    | ASCII 코드 | URL의 예                                               |
| ------- | ---------- | ------------------------------------------------------ |
| ~       | 126 (0x7E) | `http://www.joes-hardware.com/%7Ejoe`                  |
| 빈 문자 | 32 (0x20)  | `http://www.joes-hardware.com/more%w0tools.html`       |
| %       | 37 (0x25)  | `http://www.joes-hardware.com/100%25satisfaction.html` |

### 2.4.3 문자 제한

몇몇 문자는 URL 내에서 특별한 의미로 예약되어 있습니다. 어떤 문자는 US-ASCII의 출력 가능한 문자 집합에 포함되어 있지 않습니다. 그리고 어떤 문자는 몇몇 인터넷 게이트웨이와 프로토콜에서 혼동되는 것으로 알려져 있어서, 사용이 꺼려지기도 했습니다.

| 문자               | 선점 및 제한                                                                                                                 |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| %                  | 인코딩된 문자에 사용할 이스케이프 토큰으로 선점                                                                              |
| /                  | 경로 컴포넌트에 있는 경로 세그먼트를 나누는 용도로 선점                                                                      |
| .                  | 경로 컴포넌트에서 선점                                                                                                       |
| ..                 | 경로 컴포넌트에서 선점                                                                                                       |
| #                  | 프래그먼트의 구획 문자로 선점                                                                                                |
| ?                  | 질의 문자열 구획 문자로 선점                                                                                                 |
| ;                  | 파라미터 구획 문자로 선점                                                                                                    |
| :                  | 스킴, 사용자 이름/비밀번호, 호스트/포트 구획 문자로 선점                                                                     |
| $ , +              | 선점                                                                                                                         |
| @ & =              | 특정 스킴에서 특별한 의미가 있기 때문에 선점                                                                                 |
| { } \\ \| ~ [ ] \` | 게이트웨이 같은 여러 전송 에이전트에서 불안전하게 다르기 때문에 제한됨                                                       |
| < > "              | 안전하지 않음. 웹 문서에서 URL을 구분 지어 표시하듯이, URL 범위 밖에서 역할이 있는 문자이기 때문에 반드시 인코딩해야 합니다. |
| 0x00-0x1F, 0x7F    | 제한됨. 이 16진수 범위에 속하는 문자들은 인쇄되지 않는 US-ASCII 문자입니다.                                                  |
| > 0x7F             | 제한됨. 이 16진수 범위에 속하는 문자들은 7비트 US-ASCII 문자가 아닙니다.                                                     |

### 2.4.4 좀 더 알아보기

애플리케이션은 전해진 방식대로 구현해야 합니다. 어떤 애플리케이션에 어떤 URL을 보내든지, 그전에 클라이언트 애플리케이션에서 안전하지 않거나 제한된 문자를 변환하는 것이 좋습니다. 안전하지 않은 모든 문자를 인코딩하기만 하면, 다른 애플리케이션으로부터 특별한 의미를 가지는 문자를 받았을 때 혼동할 걱정 없이, 애플리케이션 간에 공유할 수 있는 URL의 원형을 유지할 수 있습니다.

입력받은 URL에서 어떤 문자를 인코딩해야 하는지 결정하는 데는 브라우저와 같이 사용자로부터 최초로 URL을 입력받는 애플리케이션에서 하는 것이 가장 적절합니다. URL을 구성하는 각 컴포넌트마다 사용할 수 있거나 없는 문자들이 있을 것이고, 또 어떤 문자는 스킴에 따라서 가용성이 달라지기 때문에, 해당 문자들을 직접 입력 받는 애플리케이션이야말로 어떤 문자를 인코딩해야 하는지 결정하기에 가장 좋은 위치라는 것입니다.

물론 극단적인 방법은 애플리케이션이 모든 문자를 인코딩하는 것입니다. 이 방식을 추천하지는 않지만, 이미 안전한 것으로 판단되는 문자를 재차 인코딩하는 것보다 더 완벽하고 빠른 규칙은 없습니다. 하지만 실제로 이 방식은 안전한 문자들을 인코딩하지 않는 애플리케이션도 있기 때문에 오동작을 일으킬 수 있습니다.

악의적인 사람들은 URL의 패턴 매칭을 하는 애플리케이션을 회피하여 다른 문자들을 인코딩하기도 합니다. 안전한 URL 컴포넌트를 인코딩하면, 패턴 매칭 애플리케이션이 원하는 패턴을 찾지 못하는 원인이 될 수 있습니다. 보통 URL을 해석하는 애플리케이션은 그것을 처리하기 전에 URL을 디코드해야 합니다.

스킴 같은 몇몇 URL 컴포넌트는 쉽게 알아볼 수 있어야 하며 알파벳 문자로 시작되어야 합니다. 각 URL ㅋ컴포넌트 간에 선점된 문자나 안전하지 않은 문자를 사용하는 방법에 대한 상세한 내용은, 앞서 다룬 **URL 문법**을 다시 참고합니다.

## 2.5 스킴의 바다

#### http

사용자 이름이나 비밀번호가 없다는 것을 제외하고는, 일반 URL포맷을 지키는 **하이퍼텍스트 전송 프로토콜**(Hypertext Transfer Protocol) 스킴입니다. 포트값이 생략되어 있으면 기본값은 80입니다.

```
http://<호스트>:<포트>/<경로>?<질의>#<프래그먼트>

http://www.joes-hardware.com/index.html
http://www.joes-hardware.com:80/index.html
```

#### https

https 스킴은 http 스킴과 거의 같습니다. 다른 점이라고는 https는 HTTP 커넥션의 양 끝단에서 암호화하기 위해 넷스케이프에서 개발한 **보안 소켓 계층**(Secure Socket Layer, SSL)을 사용한다는 것뿐입니다. 문법은 HTTP와 같고 기본 포트값은 443입니다.

```
https://<호스트>:<포트>/<경로>?<질의>#<프래그먼트>

https://www.joes-hardware.com/secure.html
```

#### mailto

mailto URL은 이메일 주소를 가리킵니다. 이메일은 다른 스킴과는 다르게 동작하기 때문에, mailto URL은 표준 URL과는 다른 포맷을 가집니다. 인터넷 이메일 주소의 문법은 RFC 822에 기술되어 있습니다.

```
mailto:<RFC-822-addr-spec>

mailto:joe@joes-hardware.com
```

#### ftp

**파일 전송 프로토콜**(File Trnsfer Protocol) URL은 FTP 서버에 있는 파일을 내려 받거나 올리고, FTP 서버의 디렉터리에 있는 콘텐츠 목록을 가져오는 데 사용할 수 있습니다. FTP는 웹과 URL이 출현하기 전부터 있었습니다. 웹 애플리케이션은 데이터에 접근하는 용도의 스킴으로 FTP를 사용합니다. URL 문법은 다음과 같이 일반적인 URL 포맷입니다.

```
ftp://<사용자 이름>:<비밀번호>@호스트:<포트>/<경로>:<파라미터>

ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/
```

#### rtsp, rtspu

RTSP URL은 **실시간 스트리밍 프로토콜**(Real Time Streaming Protocol)을 통해서 읽을 수 있는 오디오 및 비디오와 같은 미디어 리소스 식별장비니다. rtspu 스킴에 있는 **u**는 리소스를 읽기 위해서 UDP 프로토콜이 사용됨을 뜻합니다.

```
rtsp://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>
rtspu://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>

rtsp://www.joes-hardware.com:554/interview/cto_video
```

#### file

file 스킴은 주어진 호스트 기기(로컬 디스크, 네트워크 파일 시스템 혹은 기타 파일 공유 시스템)에서 바로 접근할 수 있는 파일들을 나타냅니다. 각 필드도 일반적인 URL 포멧을 따릅니다. 만약 호스트가 생략되어 있으면, URL을 사용하고 있는 기기의 로컬 호스트가 기본값이 됩니다.

```
file://<호스트>/<경로>

file://OFFICE-FS/policies/casual-fridays.doc
```

#### news

news 스킴은 RFC 1036에 정의된 바와 같이 특정 문서나 뉴스 그룹에 접근하는데 사용합니다. new URL은 리소스이 위치 정보를 충분히 포함하지 않는 특이한 속성이 있습니다. new RUL은 해당 리소스가 어디에 있는지에 대한 정보를 포함하지 않습니다. 호스트 명이나 서버 이름도 제공하지 않습니다. 사용자로부터 그 정보를 알아내는 것은 애플리케이션의 몫입니다. 예를 들어, 넷스케이프 브라우저의 옵션 메뉴에서 NNTP(news) 서버를 명시할 수 있습니다. URL을 입력 받은 브라우저는, 현재 설명되어 있는 뉴스 서버 정보를 사용하여 ㅇ어떤 서버로부터 뉴스를 가져올지 결정합니다.

뉴스 리소스는 여러 서버를 통해 접근할 수 있습니다. 뉴스 리소스에 접근하는 것이 하나의 서버로만 접근할 수 있는 게 아니므로, 위치에 독립적이라고 할 수 있습니다. news URL에서 선점한 `@` 문자는 뉴스 그룹을 가리키는 뉴스 URL과 특정 뉴스 문서를 가리키는 뉴스 URL을 구분하기 위해 사용합니다.

```
news:<newsgroup>
news:<news-article-id>

news:rec.arts.startrek
```

#### telnet

telnet 스킴은 대화형 서비스에 접근하는데 사용합니다. telnet URL 자체가 객체를 가리키지는 않지만, 리소스라고 할 수 있는 대화형 애플리케이션은 이 telnet 프로토콜을 통해 접근할 수 있습니다.

```
telnet://<사용자 이름>:<비밀번호>@<호스트>:<포트>/

telnet://slurp:webhound@joes-hardware.com:23/
```

## 2.6 미래

URL은 강력한 도구입니다. URL은 세상에 존재하는 모든 객체에 이름을 지을 수 있고, 새로운 포맷을 쉽게 추가할 수 있게 설계됐습니다. URL은 인터넷 프로토콜 간에 공유할 수 있는 일관된 작명 규칙을 제공합니다. 하지만 URL이 완벽한 것은 아닙니다. 사실 URL은 주소이지 실제 이름은 아닙니다. 이는 URL이 특정 시점에 어떤 것이 위차한 곳을 알려준다는 것을 뜻합니다. URL은 리소스를 찾는데 필요한 포트와 서버 이름을 제공합니다. 이런 스킴의 단점은 리소스가 옮겨지면 URL을 더는 사용할 수 없다는 것입니다. 그리고 그 시점에 기존 URL이 가리키고 있던 객체를 찾을 방법이 없어집니다.

이런 문제를 예방할 수 있는 이상적인 방법은, 객체의 위치와 상관없이, 그 객체를 가리키는 실제 객체의 이름을 사용하는 것입니다. 사람처럼 리소스의 이름과 다른 몇 가지 정보만 있으면 그것의 위치가 바뀌더라도 리소스의 위치를 찾을 수 있습니다. **인터넷 기술 테스크 포스**(Internet Engineering Task Force, IEFT)는 한동안 고심한 끝에 **URN**(Uniform Resource Names)이라는 새로운 표준 작업에 착수하였습니다. URN은 객체가 옮겨지더라도 항상 객체를 가리킬 수 있는 이름을 제공합니다.

**지속 통합 자원 지시자**(Persistent Uniform Resource Locators, PURL)을 사용하면 URL로 URN의 기능을 제공할 수 있습니다. PURL은 리소스의 실제 URL 목록을 관리하고 추적하는 리소스 위치 중개 서버를 두고, 해당 리소스를 우회적으로 제공합니다. 클라이언트는 위치 할당자에게 리소스를 가져올 수 있는 영구적인 URL을 요청할 수 있으며, 영구적인 URL은 클라이언트를 리소스의 실제 URL로 연결해줍니다. PURL에 대한 더 자세한 정보는 [http://purl.oclc.org](http://purl.oclc.org)를 참고합니다.

### 2.6.1 지금이 아니면, 언제?

URL에서 URN으로 주소 체계를 바꾸는 것은 매우 큰 작업입니다. 표준화는 매우 중요한 작업인 만큼 느리게 진행될 때도 있습니다. URN을 지원하려면 많은 변화가 필요할 것입니다. 쵸준을 제정하는 것에서부터 여러 HTTP 애플리케이션을 수정하기 위한 밴더들과의 함의도 필요합니다. 그러한 변화를 만들어내기 위해서는 엄청난 작업량이 필요하고, 유감스럽게도 URN으로 전환하기 위한 모든 것이 준비되려면 심간이 걸리기 떄문에, URL은 당분간 계속 사용될 것입니다.

웹이 폭발적으로 성장함에 따라 인터넷 사용자는 URL의 사용법을 배워왔습니다. 그들은 URL의 어설픈 문법과 고질적이 ㄴ문제로 고통받으면서도, 그것의 사용 방법과 함꼐 결점을 다루는 방법을 익혔습니다. URL은 나름의 한계를 가지고 있지만, 웹 개발 커뮤니티에서 이를 가장 긴급한 사안이라고 이야기하지는 않습니다.

URL은 현재는 물론 가까운 미래에도 인터넷에 있는 리소스를 명명하는 방법이 될 것입니다. 그것은 어디에나 쓰일 것이고 웹이 성공하는데 있어 매우 중요한 부분임이 입증될 것입니다. URL은 그것을 대체할 수 있는 작명 스킴이 나오기 전까지는 계속 사용될 것입니다. 다만 URL은 그 한계를 가진 상태에서, 그것을 해결할 수 있는 새로운 표준 같은 것들이 나오고 적용될 것입니다.
