# Array vs Linked List

## 1. Array

가장 기본적 자료구조인 Array 자료구조는, **논리적 저장 순서와 물리적 저장 순서가 일치**합니다. 따라서 인덱스(index)로 해당 원소에 접근할 수 있습니다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 `Big-O(1)`에 해당 원소로 접근할 수 있습니다. 즉 **Random Access가 가능**하다는 장점이 있습니다.

하지만 **삭제 또는 삽입의 과정에서 해당 원소에 접근하여 작업을 완료한 뒤, 한가지의 작업을 추가적으로 해줘야 하기 때문에 시간이 더 걸립니다.** 만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 됩니다. 즉 빈공간이 생깁니다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들은 **shift** 해줘야 하는 비용이 발생하고 이 경우의 시간 복잡도는 `O(n)`이 됩니다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complextity의 worst case는 `O(n)`입니다.

삽입의 경우도 마찬가지입니다. 만약 첫번쨰 자리에 새로운 원소를 추가하고자 한다면 모든 원소드르이 인덱스를 1씩 **shift** 해줘야 하므로 이 경우도 O(n)의 시간을 요구하게 됩니다.

## 2. Linked List

이 부분에 대한 문제점을 해결하기 위한 자료구조가 **linked list**입니다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있습니다. 따라서 이 부분만 다른 값으로 바꿔주면 **삭제와 삽입을 O(1)만에 해결**할 수 있습니다.

하지만 Linked List 역시 한 가지 문제가 있습니다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 **Search 과정에 있어서 첫번째 원소부터 다 확인**해봐야 한다는 것입니다. Array와 달리 **논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문**입니다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지 입니다. 이 과정 때문에, 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 `O(n)`의 시간이 추가적으로 발생합니다.

결국 linked list 자료구조는 search해도 `O(n)`의 time complexity를 갖고, 삽입, 삭제에 대해서도 O(n)의 time complexity를 갖습니다. 그렇다고 해서 아주 쓸모없는 자료구조는 아니기에, 우리가 학습하는 것입니다. 이 Linked List는 Tree 구조의 근간이 되는 자료구조이며, Tree에서 사용되었을 때 그 유용성이 드러납니다.

## 출처

- [Interview_Question_for_Beginner - JaeYeopHan](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#array-vs-linked-list)
