# Tree

트리는 스택이나 큐와 같은 선형 구조가 아닌 비선형 구조입니다. 트리는 계층적 관계(Hierarchical Relationship)를 표현하는 자료구조입니다. 이 **트리**라는 자료구조는 표현에 집중합니다. 무엇인가를 저장하고 꺼내야 한다는 사고에서 벗어나 트리라는 자료구조를 바라봐야 합니다.

## 1. 용어 정리

- **Node:** 트리를 구성하고 있는 각각의 요소를 의미합니다.
- **Edge:** 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미합니다.
- **Root Node:** 트리 구조에서 최상위에 있는 노드를 의미합니다.
- **Terminal Node(Leaf Node, 단말 노드):** 하위에 다른 노드가 연결되어 있지 않은 노드를 의미합니다.
- **Internal Node(내부 노드, 비단말 노드):** 단말 노드를 제외한 모든 노드로 루트 노드를 포함합니다.

## 2. Binary Tree

**루트 노드를 중심으로 두 개의 서브 트리**(큰 트리에 속하는 작은 트리)로 나뉘어 집니다. 또한 나뉘어진 두 서브 트리도 모두 이진 트리어야 합니다. 공집합도 이진 트리로 포함시켜야 합니다. 그래야 재귀적으로 조건을 확인할 때, Leaf Node에서도 정의가 만족되기 때문입니다. 자연스럽게 노드가 하나 뿐인 것도 이진 트리 정의에 만족하게 됩니다.

트리에서는 각 **층별로 숫자를 매겨서 이를 트리의 레벨**이라고 합니다. 레벨의 값은 0부터 시작하고 따라서 루트 노드의 레벨은 1입니다. 그리고 트리의 **최고 레벨을 가리켜 해당 트리의 높이**라고 합니다.

- **Perfect Binary Tree(포화 이진 트리):** 모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진 트리라고 합니다.
- **Complete Binary Tree(완전 이진 트리):** 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡 차곡 채워진 이진 트리를 가리켜 완전 이진 트리라고 합니다.
- **Full Binary Tree(정 이진 트리):** 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리를 가리켜 정 이진 트리라고 합니다.

## 3. BST (Binary Search Tree)

효율적인 탐색을 위해서는 어떻게 찾을까만 고민해서는 안됩니다. 그보다는 효율적인 탐색을 위한 저장방법이 무엇일까를 고민해야 합니다. 이진 탐색 트리는 이진 트리의 일종입니다. 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있습니다. 그리고 그 규칙을 특정 데이터의 위치를 찾는데 사용할 수 있습니다.

1. 이진 탐색 트리의 노드에 저장된 키는 유일하다
2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
4. 왼쪽과 오른족 서브트리도 이진 탐색 트리이다.

이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 가집니다. 사실 정확히 말하면 O(h)라고 표현하는 것이 맞습니다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문입니다. 하지만 이러한 이진 탐색 트리는 **Skewed Tree(편향 트리)가 될 수 있습니다.** 저장 순서에 따라 계속 한 쪽으로만 노드가 붙게되는 경우가 발생하기 때문입니다. 이럴 경우 성능에 영향을 미치게 되며, 탐색의 Worst Case가 되고 시간 복잡도는 O(n)이 됩니다.

배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생합니다. 이를 해결하기 위해 Rebalancing 기법이 등장했습니다. **균형을 잡기 위한 트리 구조의 재조정을 Rebalancing**이라 합니다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나가 뒤에서 살펴볼 **Red-Balck Tree**입니다.

## 4. Binary Heap

자료구조의 일종으로 Tree의 형식을 하고 있으며, Tree 중에서도 **배열에 기반한 Complete Binary Tree**입니다. 힙(Heap)에는 **최대 힙(Max Heap)**, **최소 힙(Min Heap)** 두 종류가 있습니다.

**Max Heap**이란, 각 노드의 값이 해당 children의 값보다 크거나 같은 **Complete Binary Tree**이기 떄문에 배열을 사용하여 효율적으로 관리할 수 있습니다. 하지만 heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요합니다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 **heapify** 과정을 거쳐 heap 구조를 유지합니다. 이런 경우에는 결국 O(log n)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있게 됩니다.

## 5. Red Black Tree

RBT(Red-Black Tree)는 **BST를 기반으로하는 트리 형식**의 자료구조입니다. 결론부터 말하자면 Red-Black Tree에 데이터를 저장하게되면 Search, Insert, Delete에 O(log n)의 시간 복잡도가 소요됩니다. 동일한 노드의 개수일 떄, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어입니다.

### 5.1 조건

1. 각 노드는 Red or Black이라는 색을 갖는다.
2. Root node의 색은 Black이다.
3. 각 Leaf Node는 Black이다.
4. 어떤 노드의 색이 Red라면 두 개의 children의 색은 모두 Black이다.
5. 각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 Black Nodes들을 포함하고 있습니다. 이를 해당 노드의 **Black-Height**라고 합니다(노드X로부터 노드X를 포함하지 않는 Leaf Node까지의 simple path 상에 있는 Black Node들의 개수).

### 5.2 Red-Black Tree의 특징

1. Binary Search Tree이므로 BST의 특징을 모두 갖습니다.
2. Root Node부터 Leaf Node까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않습니다. 이러한 상태를 **balanced** 상태라고 합니다.
3. 노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장합니다. 이런한 NIL들을 Leaf Node로 간주합니다.

RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조입니다.

### 5.3 삽입

우선 BST의 특성을 유지하면서 노드를 삽입합니다. 그리고 삽입된 노드의 색을 **Red**로 지정합니다. Red로 지정하는 이유는 Black-Height 변경을 최소화하기 위함입니다. 삽입 결과 RBT의 특성 위배(violation)시 노드의 노드의 색을 조정합니다.

#### 5.3.1 Restructing

부모의 형제가 Black일 때 수행합니다.

1. 삽입된 노드의 부모와, 부모의 부모를 오름차순으로 정렬합니다.
2. 가운데 값을 부모로 만들고, 나머지를 자식으로 만듭니다.
3. 부모가 된 노드를 Black으로 만들고, 자식이 된 노드를 Red로 만듭니다.
4. 원래 부모의 형재였던 노드를 추가합니다.

Restructuring은 다른 서브트리에 영향을 끼치지 않기 때문에 한번의 Restructuring이면 끝납니다. Double Red를 해결하기 전과 해결 한 후의 Black 노드의 개수에 변화가 없기때문에 다른서브트리에 영향을 끼치지 않게 됩니다.

#### 5.3.2 Reoloring

부모의 형제가 Red일 때 수행합니다.

1. 부모와 부모의 형제를 Black으로 변경합니다.
2. 부모의 부모를 Red로 변경합니다.
3. 부모의 부모가 Root면 다시 Black으로 변경합니다.
4. 부모의 부모가 Root가 아니고 Double Red의 문제가 생긴다면, Restructing 혹은 Recoloring을 진행합니다.

### 6.3 삭제

삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제합니다. 삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게 됩니다. 그리고 만약 지워진 노드의 색이 **Black**이라면 Black-Height가 1 감소한 경로에 black node가 1개 추가되도록 rotaition하고 노드의 색을 조정합니다. 지워진 노드의 색이 **Red**라면 Violation이 발생하지 않으므로 RBT가 유지됩니다.

## 7. 출처

- [Interview_Question_for_Beginner - JaeYeopHan](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#array-vs-linked-list)
- [알고리즘 ) Red-Black Tree - Zed0202](https://zeddios.tistory.com/237)
