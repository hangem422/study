# Hash Table

해시 테이블은 연관 배열 구조를 이용하여 **키**(Key)에 결과 **값**(Value)를 저장하는 자료구조입니다. 내부적으로 연관 배열 구조를 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖습니다. 연관 배열 구조란, 키 1개와 값 1개가 1:1로 연관되어 있는 자료구조 입니다. 특정한 값을 Search하는데 데이터 고유의 인덱스로 접근하게 되므로 Average Case에 대해서 Time Comlpexity가 O(1)이 되는 것입니다. (항상 O(1)이 아니고 Average Case에 대해서 O(1)인 것은 Collision 때문입니다.) 하지만 문제는 이 인덱스로 저장되는 키값이 불규칙하다는 것입니다.

그래서 특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유 숫자를 만들어 낸 뒤 이름 인덱스로 사용합니다. 특정 데이터가 저장되는 인덱스는 그 데이터만 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조입니다.

## 1. 용어 정리

![Hash Table](../_images/data-structure-hash01.png)

### 1.1 Key

고유한 값이며, Hash Function의 input이 됩니다. 다양한 길이의 값이 될 수 있습니다. 이 상태로 최종 장소에 지정이 되면 다양한 길이 만큼의 저장소를 구성해 두어야 하기 때문에 해시 함수로 값을 바꾸어 지정이 되어야 공간의 효율성을 추구할 수 있습니다.

### 1.2 Hash Function

**특별한 알고리즘**이란 것을 통해 고유한 인덱스 값을 설정하는 것이 중요해보입니다. 위에서 언급핸 특별한 알고리즘을 **해시 함수**(Hash Function)이라고 하며, 이 메소드에 의해 변환된 데이터의 고유 숫자 값을 **Hash Code**라고 합니다. 지정되는 값들의 Key 값을 Hash Function을 통해서 작은 범위의 값들로 바꿔줍니다.

하지만 어설픈 Hash Function을 통해서 Key 값을을 결정한다면 동일한 값이 도출될 수가 있습니다. 이렇게 되면 동일한 Key 값에 복수개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데 이를 **Collision**이라고 합니다.Colloision으로 서로 다른 두 개의 키가 같은 인덱스로 Hashing되면 같은 곳에 저장할 수 없게 됩니다. 그렇다면 좋은 Hash Function은 어떠한 조건들을 갖추고 있어야 할까요?

일반적으로 좋은 Hash Function은 키의 일부분을 참조하여 해쉬 값을 만들지 않고 키 전체를 참조하여 해쉬 값을 만들어냅니다. 하지만 좋은 해쉬 함수는 키가 어떤 특성을 가지고 있느냐에 따라 달라지게 됩니다. Hash Function을 무조건 1:1로 만드는 것보다 Collision을 최소화하는 방향으로 설계하고 발생하는 Collision에 대비해 어떻게 대응할 것인가가 더 중요합니다. 1:1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런 Hash Function을 만들어봤자 그건 Array와 다를바 없고 메모리를 너무 차지하게 됩니다.

Collision이 많아질 수록 Search에 필요한 Time Complexity O(1)에서 O(n)에 가까워집니다. 어설픈 Hash Function은 Hash를 Hash답게 사용하지 못하도록 합니다. 좋은 Hash Function을 선택하는 것은 Hash Table의 성능 향상에 필수적인 것입니다.

### 1.3 Value

**저장소**(Bucket, Slot)에 최종적으로 저장되는 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능해야 합니다.

## 2. Hash Collision

Hashing된 인덱스에 이미 다른 값이 들어 있다면 새 데이터를 저장할 위치를 찾은 뒤에야 저장할 수 있는 것입니다. 따라서 충돌 해결은 필수이며 기본적으로 두 가지 방법부터 알아봅니다. 해시 충돌을 해결하기 위해 다양한 자료가 있지만, 다음 두 가지 방법을 응용한 방법이기 때문입니다.

### 2.1 Open Address 방식 (개방주소법)

해시 충돌이 발생하면, (즉 삽입하려는 해시 버킷이 이미 사용 중인 경우) 다른 해시 버킷에 해당 자료를 삽입하는 방식입니다. 버킷이라면 바구니와 같은 개념으로 데이터를 저장하기 위한 공간이라고 생각하면 됩니다. 다른 해시 버킷이라면 어떤 해시 버킷을 말하는 걸까요?

공개 주소 방식이라고도 불리는 이 알고리즘은 Collision이 발생하면 데이터를 저장할 장소를 찾아 해맵니다. Worst Case의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 돌아올 수 있습니다. 이 과정에서도 여러 방법들이 존재하는데, 다음 세 가지에 대해 알아봅시다.

1. **Linear Probing**: 다음 해시나 n개를 건너뛰어 비어있는 해시에 데이터를 저장합니다.
2. **Quadratic Probing**: 충돌이 일어난 해시의 제곱을 한 해시에 데이터를 저장합니다.
3. **Double Hashing Probing**: 다른 해시함수를 한번 더 적용한 해시에 데이터를 저장합니다. 위 두가지 방법에 비해 많은 연산량을 요구하게 됩니다.

### 2.2 Separate Chaining 방식 (분리 연결법)

일반적으로 Open Addressing은 Separate Chaining보다 느립니다. Open Addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문입니다. 반면 Separate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 Worst Case에 가까워지는 빈도를 줄일 수 있습니다.

- **연결 리스트를 사용하는 방식**(Linked List): 각각의 버킷들을 연결리스트로 만들어 Collision이 발생한다면 해당 Bucket의 List에 추가하는 방식입니다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단합니다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저정할 때 연결 리스트 자체의 오버헤드가 부담이 됩니다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 비해 테이블의 확장을 늦출 수 있습니다.
- **Tree를 사용하는 방식**(Red Black Tree): 기본적인 알고리즘 Sparate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식입니다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 Key-Value 쌍의 개수입니다. 데이터 개수가 적다면 링크드 리스트를 사용하는 것이 맞습니다. 트리는 기본적으로 메모리 사용량이 많기 때문입니다. 데이터 개수가 적을 때 Worst Case를 살펴보면 트리와 링크드 리스트의 성능상 차이가 거의 없습니다. 따라서 메모리 측면으로 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용합니다.

데이터가 적다는 것은 얼마나 적다는 것을 의미할까요? 앞에서 말했듯이 기준은 하나의 해시 버킷에 할당된 Key-Value 쌍의 개수입니다. 쌍의 개수가 6개, 8개를 기준으로 결정합니다. 기준이 두개인 것을 이상하게 느낄 수 있습니다. 7은 어디로 갔을까요? Linked List의 기준 트리의 기준을 6과 8로 잡은 것은 변경하는데 소요되는 비용을 줄이기 위함입니다.

한가지 가정을 해봅시다. 해시 버킷에 6개의 Key-Value 쌍이 들어있습니다. 그리고 하나의 값이 추가되었습니다. 만약 기준이 6과 7이라면 자료구조를 Linked List에서 트리로 변경해야 합니다. 그러다 바로 하나의 값이 삭제된다면 다시 트리에서 Linked List로 자료구조를 변경해야 합니다. 각각 자료구조로 넘어가는 기준이 1이라면, Switching 비용이 너무 많이 필요하게 됩니다. 그래서 2라는 여유르 남겨주고 기준을 잡아준 것입니다. 따라서 데이터 개수가 6개에서 7개로 증가했을 때는 Linked List 자류 구조를 취하고 있을 것이고 8개에서 7개로 감소했을 때는 트리의 자료구조를 취하고 있을 것입니다.

#### 2.2.1 보조 해시 함수 (Supplement Hash Function)

보조 해시 함수의 목적은 Key의 해시 값을 변형하여 해시 충돌 가능성을 줄이는 것입니다. Separate Chaining 방식을 사용할 때 함꼐 사용되며 보조 해시 함수로 Worst Case에 가까워지는 경우를 줄일 수 있습니다.

### 2.3 Open Address vs Separate Chainging

##### open Address

- 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능합니다.
- Hash Function의 성능에 전체 해시 테이블 성능이 좌지우지됩니다.
- 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 주어야 합니다.

##### Separate Chaining

- 한정된 저장소를 효율적으로 사용할 수 있습니다.
- Hash Function을 선택하는 중요성이 상대적으로 낮습니다.
- 상대적으로 적은 메모리를 사용하고, 미리 공간을 잡아 놓을 필요가 없습니다.
- 한 Hash에 자료들이 밀집된다면 검색 효율을 낮출 수 있습니다.
- 외부 저장 공간을 사용합니다.

일단 두 방식 모두 Worst Case에서 O(M)입니다. 하지만 Open Address 방식은 연속된 공간에 테이블을 저장하기 때문에 Separate Chaining에 비해 캐시 효율이 높습니다. 따라서 데이터의 개수가 충분히 적다면 Open Address 방식이 Separate Chaining보다 성능이 좋습니다. 한 가지 차이점이 더 존재합니다. Separate Chaining 방식에 비해 Open Address 방식은 버킷을 계속해서 사용합니다. 따라서 Separate Chaining 방식은 테이블의 확장을 보다 늦출 수 있습니다.

## 3. 해시 버킷 동적 확장 (Resize)

해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있3지만 해시 충돌로 인해 성능 상 손실이 발생합니다. 그래서 HashMap은 Key-Value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘립니다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느정도 해결할 수 있습니다. 해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때입니다. 0.75라는 숫자는 Load Factor라고 불립니다.

## 4. 출처

- [Interview_Question_for_Beginner - JaeYeopHan](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#array-vs-linked-list)
- [Hash, Hashing, Hash Table(해시, 해싱 해시테이블) 자료구조의 이해 - cyranocoding](https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o)
